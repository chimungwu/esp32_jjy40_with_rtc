//   ç”± Chimung æ ¹æ“š ver.0.1ï¼ˆ2024/05/16 by Nash Shuji009ï¼‰æ”¹å¯«èˆ‡å¼·åŒ–ï¼Œç‰ˆæœ¬ ver.0.12ï¼ˆ2025/05/10ï¼‰
//
// ğŸ“¡ ESP32 JJY 40kHz é›»æ³¢æ™‚è¨ˆç™¼å°„å™¨æ¨¡æ“¬å™¨ï¼Œæ”¯æ´ NTP å°æ™‚ã€RTC å‚™æ´ã€LCD é¡¯ç¤ºèˆ‡ WiFiManager è¨­å®š
//
// ğŸ› ï¸ åŠŸèƒ½ç‰¹è‰²ï¼š
//   - ä½¿ç”¨ GPIO26 è¼¸å‡º 40kHz PWM è¨Šè™Ÿï¼Œæ¨¡æ“¬æ—¥æœ¬ JJY æ¨™æº–é›»æ³¢æ™‚ç¢¼
//   - é–‹æ©Ÿæ™‚è‡ªå‹•é€é WiFi é€£ç·šä¸¦åŒæ­¥ NTP æ™‚é–“ï¼Œæ”¯æ´å¾®ç§’ç´šæ•´ç§’å°é½Š
//   - æ”¯æ´ DS3231 RTC æ¨¡çµ„ä½œç‚ºé›¢ç·šå‚™æ´æ™‚é˜ï¼Œèˆ‡ LCD ä½¿ç”¨ä¸åŒ IÂ²C æ§åˆ¶å™¨
//   - è‹¥ WiFi æˆ– NTP åŒæ­¥å¤±æ•—ï¼Œè‡ªå‹• fallback ç‚º RTC æ¨¡çµ„æ™‚é–“ç¹¼çºŒé‹ä½œ
//   - æ•´åˆ WiFiManagerï¼šè‹¥ç„¡å·²çŸ¥ WiFiï¼Œè‡ªå‹•å•Ÿç”¨ AP æ¨¡å¼ï¼ˆSSID: JJY_Configï¼‰é€²å…¥è¨­å®šç•«é¢
//   - ä½¿ç”¨è€…å¯é€é WiFiManager è‡ªè¨‚æ™‚å€ï¼ˆå¦‚ +8 å°ç£ã€+9 æ—¥æœ¬ï¼‰åŠå¤šä¹…é‡æ–°æ ¡æ™‚(hr)ï¼Œä¸¦å¥—ç”¨è‡³ç³»çµ±
//   - LCD1602 è¢å¹•æ¯ç§’é¡¯ç¤ºå°ç£æ™‚é–“ã€å¯¦éš›ç™¼é€æ™‚é–“ã€ä¾†æºï¼ˆNTP æˆ– RTCï¼‰ã€èˆ‡ç›®å‰æ™‚å€è¨­å®š
//   - sg[] æ™‚ç¢¼é™£åˆ—åŠ å…¥éŒ¯èª¤æª¢æŸ¥é˜²å‘†æ©Ÿåˆ¶ï¼Œé¿å…éŒ¯èª¤å€¼å°è‡´æ™‚ç¢¼ç•°å¸¸
//   - Serial è¼¸å‡ºè©³ç´°é™¤éŒ¯è³‡è¨Šï¼šåŒ…å« WiFi ç‹€æ…‹ã€RTC ç‹€æ…‹ã€å°æ™‚éç¨‹èˆ‡æ¯ç§’ç™¼æ³¢å…§å®¹
//
// ğŸ§· ç¡¬é«”æ¥ç·šèªªæ˜ï¼š
//   - ç™¼æ³¢ç·šåœˆï¼ˆJJY å¤©ç·šï¼‰ï¼šGPIO26 â†’ 220Î© â†’ ç·šåœˆ â†’ GND
//   - RTCï¼ˆDS3231 æ¨¡çµ„ï¼‰ï¼šSDA=GPIO17ã€SCL=GPIO16ï¼ˆç¨ç«‹ IÂ²C æ§åˆ¶å™¨ I2C_RTCï¼‰
//   - LCDï¼ˆIÂ²C ä»‹é¢ï¼‰ï¼šSDA=GPIO21ã€SCL=GPIO22ï¼ˆä½¿ç”¨é è¨­ Wireï¼‰
//   - WiFi ç‹€æ…‹æŒ‡ç¤ºç‡ˆï¼ˆé¸é…ï¼‰ï¼šGPIO2ï¼ˆæˆåŠŸé€£ä¸Š WiFi æ™‚é»äº®ï¼‰

#include <Arduino.h>
#include <driver/ledc.h>         // ESP32 çš„ LEDC PWM æ§åˆ¶å™¨ï¼Œç”¨æ–¼ç”¢ç”Ÿ 40kHz
#include <WiFi.h>                // WiFi é€£ç·šåŠŸèƒ½
#include <RtcDS3231.h>          // RTC DS3231 æ™‚é˜æ¨¡çµ„å‡½å¼åº«
#include <WiFiManager.h>        // è‡ªå‹• WiFi ç®¡ç†èˆ‡è¨­å®šé é¢
#include <Wire.h>               // IÂ²C é€šè¨Šå‡½å¼åº«ï¼ˆç”¨æ–¼ LCDï¼‰
#include <LiquidCrystal_I2C.h>  // LCD1602 IÂ²C é¡¯ç¤ºæ¨¡çµ„

// LCD è¢å¹•åˆå§‹åŒ–ï¼ˆé è¨­ä½å€ 0x27ï¼Œ16x2 å­—å…ƒï¼‰
LiquidCrystal_I2C lcd(0x27, 16, 2); 

// RTC ä½¿ç”¨ç¨ç«‹ IÂ²C æ§åˆ¶å™¨ 1ï¼Œå°æ‡‰è…³ä½ç‚º GPIO17ï¼ˆSDAï¼‰èˆ‡ GPIO16ï¼ˆSCLï¼‰
TwoWire I2C_RTC(1);  
RtcDS3231<TwoWire> rtc(I2C_RTC);  // ä»¥ I2C_RTC é€£æ¥ DS3231

// é è¨­æ™‚å€ï¼ˆä»¥ç§’ç‚ºå–®ä½ï¼‰ï¼šæ—¥æœ¬ +9 å°æ™‚ï¼Œå°ç£ +8 è«‹æ–¼ WiFiManager è‡ªè¨‚
long timeZoneOffset = 9 * 3600L;

// PWM èˆ‡ç‹€æ…‹ç‡ˆç›¸é—œè…³ä½è¨­å®š
const int ledChannel = 0;        // PWM é€šé“ï¼ˆç”¨æ–¼è¼¸å‡º 40kHzï¼‰
const int ledPin = 26;           // JJY è¨Šè™Ÿè¼¸å‡ºè…³ä½ï¼ˆå»ºè­°æ¥ 220Î© é›»é˜»ï¼‰
const int wifiStatusLED = 2;     // WiFi é€£ç·šç‹€æ…‹æŒ‡ç¤ºç‡ˆï¼ˆGPIO2ï¼Œé€£ç·šæˆåŠŸæ™‚é»äº®ï¼‰

// JJY æ™‚ç¢¼æ‰€éœ€çš„æš«å­˜è®Šæ•¸
char P0, P1, P2, P3, P4, P5;
const char M = P0 = P1 = P2 = P3 = P4 = P5 = -1;  // JJY ä¸­ä»£è¡¨ã€Œæ¨™è¨˜ç§’ã€çš„ç‰¹æ®Šå€¼ -1

char PA1, PA2, SU1, LS1, LS2;    // å¥‡å¶æª¢æŸ¥ä½èˆ‡é–ç§’æ——æ¨™ç­‰

// JJY æ™‚ç¢¼å„²å­˜é™£åˆ— sg[0~59] ç‚ºæ¯ç§’è³‡æ–™ï¼Œ60~61 ç‚ºå®‰å…¨ç·©è¡ç”¨
char sg[62];

// NTP ç²¾æº–å°æ™‚å¾Œçš„æ™‚é–“åŸºæº–
uint64_t ntpSyncedMicros = 0;    // ç´€éŒ„å°æ™‚æ™‚çš„å¾®ç§’æ™‚é–“
time_t ntpSyncedTime = 0;        // å°æ™‚æ™‚å°æ‡‰çš„ UTC ç§’æ•¸

//è‡ªå‹•é‡æ–°å°æ™‚æ©Ÿåˆ¶
unsigned long lastSyncMillis = 0;
int autoSyncHour = 6;  // é è¨­æ¯ 6 å°æ™‚é‡æ–°å°æ™‚
unsigned long syncInterval = 6UL * 60UL * 60UL * 1000UL;

void setup() {
  // âœ… åˆå§‹åŒ– RTCï¼ˆDS3231ï¼‰ä½¿ç”¨ç¨ç«‹ IÂ²C ç·šï¼ˆGPIO17 / GPIO16ï¼‰
  I2C_RTC.begin(17, 16);  
  rtc.Begin();

  // âœ… åˆå§‹åŒ– LCD é¡¯ç¤ºå™¨
  Wire.begin(21, 22);     // LCD ç”¨é è¨­çš„ Wireï¼ˆI2C0ï¼‰
  lcd.begin();        
  lcd.backlight();    
  lcd.clear();        
  lcd.setCursor(0, 0);
  lcd.print("JJY TX Booting...");

  // âœ… è¨­å®š WiFi ç‹€æ…‹ç‡ˆè…³ä½
  pinMode(wifiStatusLED, OUTPUT);
  digitalWrite(wifiStatusLED, LOW);  // é è¨­é—œé–‰

  // âœ… å•Ÿå‹•åºåˆ—åŸ é™¤éŒ¯è¼¸å‡º
  Serial.begin(115200);
  delay(100);
  Serial.println("ğŸŸ¢ setup é–‹å§‹");

    // LCD é¡¯ç¤ºè¨­å®šæç¤º
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print(" Setup WiFi Via");
    lcd.setCursor(0, 1);
    lcd.print("SSID: JJY_config");

WiFiManagerParameter tzParam("tz", "Time Zone (e.g. +9 for JST, +8 for TWN)", "+9", 4);
WiFiManagerParameter syncParam("sync", "Auto Sync Interval (hr)", "6", 3);

WiFiManager wm;
wm.setDebugOutput(true);
wm.setConfigPortalTimeout(30);     // è¨­å®šé ä¿ç•™ 30 ç§’
wm.setConnectTimeout(20);
wm.addParameter(&tzParam);
wm.addParameter(&syncParam);

// å•Ÿå‹•è¨­å®šé ï¼ˆéé˜»å¡ï¼‰
wm.startConfigPortal("JJY_Config", "");  // "" è¡¨ç¤ºç„¡å¯†ç¢¼
unsigned long configStart = millis();

while (!wm.getWiFiIsSaved() && (millis() - configStart < 30000)) {
  wm.process();       // éé˜»å¡è™•ç† WiFiManager
  delay(100);
}

// æ™‚é–“åˆ°æˆ–è¨­å®šå®Œæˆï¼Œé—œé–‰è¨­å®šé ä¸¦å˜—è©¦é€£ç·šè¨˜æ†¶çš„ WiFi
WiFi.mode(WIFI_STA);
WiFi.begin();

unsigned long connectStart = millis();
while (WiFi.status() != WL_CONNECTED && millis() - connectStart < 10000) {
  delay(500);
  Serial.print(".");
}

if (WiFi.status() == WL_CONNECTED) {
  Serial.println("\nâœ… WiFiManager æˆåŠŸé€£ç·š");
  digitalWrite(wifiStatusLED, HIGH);

  const char* tzInput = tzParam.getValue();
  if (tzInput && strlen(tzInput) > 0) {
    int tzHour = atoi(tzInput);
    timeZoneOffset = tzHour * 3600;
    Serial.printf("ğŸŒ ä½¿ç”¨è€…è¨­å®šæ™‚å€ç‚ºï¼šUTC %+dï¼ˆ%d ç§’ï¼‰\n", tzHour, timeZoneOffset);
  }

  const char* syncInput = syncParam.getValue();
  if (syncInput && strlen(syncInput) > 0) {
    int hr = atoi(syncInput);
    autoSyncHour = hr;
    syncInterval = (unsigned long)hr * 60UL * 60UL * 1000UL;
    Serial.printf("ğŸ” è‡ªå‹•æ ¡æ™‚é–“éš”ï¼šæ¯ %d å°æ™‚\n", autoSyncHour);
  }

} else {
  Serial.println("âŒ WiFiManager é€£ç·šå¤±æ•—ï¼Œè«‹æª¢æŸ¥è¨­å®š");
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("WiFi Failed");
  lcd.setCursor(0, 1);
  lcd.print("Use RTC Time");
}


  // âœ… å˜—è©¦å–å¾— NTP æ™‚é–“
  bool ntpSuccess = false;
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("âœ… WiFi å·²é€£ç·š");
    configTime(timeZoneOffset, 0, "time.stdtime.gov.tw", "time.google.com", "pool.ntp.org");

    struct tm timeInfo;
    for (int i = 0; i < 3; i++) {
      if (getLocalTime(&timeInfo)) {
        if (timeInfo.tm_year >= 120) {
          // ç­‰å¾…ã€Œæ•´ç§’äº¤ç•Œé»ã€
          time_t rawtime;
          time(&rawtime);
          while (time(nullptr) == rawtime) {
            delay(1);
          }

          // å†æ¬¡å–å¾—ç²¾ç¢ºæ•´ç§’æ™‚é–“
          getLocalTime(&timeInfo);

          // ç´€éŒ„å°æ™‚ç”¨çš„ NTP åŸºæº–ï¼ˆç§’èˆ‡å¾®ç§’ï¼‰
          time_t ntpEpoch;
          time(&ntpEpoch);
          ntpSyncedMicros = esp_timer_get_time();
          ntpSyncedTime = ntpEpoch;

          // ç­‰å¾…ä¸‹ä¸€å€‹æ•´åˆ†é˜èµ·é»ï¼Œç¢ºä¿ sg[] è¨ˆç®—èˆ‡å‚³é€å°é½Š
          delayUntilAlignedRTCWrite();

          // å¯«å…¥ RTC æ¨¡çµ„
          RtcDateTime ntpTime(
            timeInfo.tm_year + 1900,
            timeInfo.tm_mon + 1,
            timeInfo.tm_mday,
            timeInfo.tm_hour,
            timeInfo.tm_min,
            timeInfo.tm_sec);
          rtc.SetDateTime(ntpTime);

          digitalWrite(wifiStatusLED, HIGH);
          Serial.printf("ğŸ“¡ ç²¾æº–å°é½Šæ•´ç§’å¾Œå¯«å…¥ RTCï¼š%04d/%02d/%02d %02d:%02d:%02d\n",
                        ntpTime.Year(), ntpTime.Month(), ntpTime.Day(),
                        ntpTime.Hour(), ntpTime.Minute(), ntpTime.Second());

          ntpSuccess = true;
          break;
        } else {
          Serial.println("âš ï¸ NTP æ™‚é–“ç„¡æ•ˆï¼ˆå¹´ä»½ < 2020ï¼‰");
        }
      } else {
        Serial.printf("âŒ› ç¬¬ %d æ¬¡å–å¾— NTP å¤±æ•—ï¼Œé‡è©¦ä¸­...\n", i + 1);
        delay(2000);
      }
    }
  } else {
    Serial.println("âŒ ç„¡æ³•é€£ä¸Š WiFi");
  }

  // â— NTP å¤±æ•—æ™‚ï¼Œæ”¹ä½¿ç”¨ RTC
  if (!ntpSuccess) {
    if (rtc.IsDateTimeValid()) {
      Serial.println("âš ï¸ ä½¿ç”¨ RTC å…§éƒ¨æ™‚é–“ï¼š");
      RtcDateTime now = rtc.GetDateTime();
      char buf[64];
      sprintf(buf, "â° RTC æ™‚é–“ï¼š%04u/%02u/%02u %02u:%02u:%02u",
              now.Year(), now.Month(), now.Day(),
              now.Hour(), now.Minute(), now.Second());
      Serial.println(buf);

      // é¡å¤–é˜²å‘†ï¼ˆé˜²æ­¢ RTC é›»æ± æ²’è£å°è‡´ç•°å¸¸ï¼‰
      if (now.Year() < 2020) {
        Serial.println("â— RTC æ™‚é–“ç•°å¸¸ï¼ˆå°æ–¼ 2020ï¼‰ï¼Œè«‹ç¢ºèª RTC é›»æ± æˆ–æ˜¯å¦å·²åˆå§‹åŒ–");
      }
    } else {
      Serial.println("ğŸ›‘ RTC æ™‚é–“ç„¡æ•ˆï¼Œç„¡æ³•å–å¾—æ­£ç¢ºæ™‚é–“ï¼");
    }
  }

  // âœ… åˆå§‹åŒ– 40kHz PWM ç™¼æ³¢å™¨
  set_fix();  // åˆå§‹åŒ– sg[] å›ºå®šä½ï¼ˆæ¨™è¨˜ç§’ç­‰ï¼‰
  ledcSetup(ledChannel, 40000, 8);        // è¨­å®š PWM é »ç‡ 40kHzï¼Œè§£æåº¦ 8-bit
  ledcAttachPin(ledPin, ledChannel);     // ç¶å®š GPIO26 ä½œç‚ºè¼¸å‡ºè…³ä½

  Serial.println("âœ… åˆå§‹åŒ–å®Œæˆï¼Œé–‹å§‹ç™¼å°„è¨ˆæ™‚æ³¢è¨Šè™Ÿ");
  lastSyncMillis = millis();  // ç¢ºä¿é¦–æ¬¡å°æ™‚å¾Œæ­£ç¢ºè¨˜éŒ„æ™‚é–“åŸºæº–
  }


void delayUntilAlignedRTCWrite() {
  struct timeval tv;
  gettimeofday(&tv, NULL);  // å–å¾—ç•¶å‰çš„ã€Œç§’æ•¸ã€èˆ‡ã€Œå¾®ç§’æ•¸ã€

  // ç›®å‰çš„æ™‚é–“ï¼ˆä»¥å¾®ç§’è¨ˆï¼‰
  int64_t micros_now = tv.tv_sec * 1000000LL + tv.tv_usec;

  // ä¸‹ä¸€å€‹æ•´åˆ†é˜çš„æ™‚é–“é»ï¼ˆä»¥å¾®ç§’è¨ˆï¼‰
  int64_t micros_next_minute = ((tv.tv_sec / 60) + 1) * 60 * 1000000LL;

  // è¨ˆç®—éœ€è¦ç­‰å¾…çš„æ™‚é–“ï¼ˆå¾®ç§’ï¼‰
  int64_t delay_us = micros_next_minute - micros_now;

  // åºåˆ—å°å‡ºå°‡ç­‰å¾…çš„æ™‚é–“ï¼ˆä»¥ç§’ç‚ºå–®ä½é¡¯ç¤ºï¼‰
  Serial.printf("â± ç­‰å¾…æ•´åˆ†é˜å°é½Šï¼š%.3f ç§’...\n", delay_us / 1000000.0);

  // åˆ†æ®µå»¶é²ï¼šå…ˆè™•ç†æ•´æ¯«ç§’ï¼Œå†è™•ç†å‰©é¤˜å¾®ç§’ï¼Œé¿å… delayMicroseconds è¶…æ™‚
  if (delay_us >= 1000) {
    delay(delay_us / 1000);             // æ•´æ¯«ç§’
    delayMicroseconds(delay_us % 1000); // å‰©é¤˜ä¸è¶³ä¸€æ¯«ç§’éƒ¨åˆ†
  } else {
    delayMicroseconds(delay_us);        // ç¸½å»¶é²æ™‚é–“å°æ–¼ 1 æ¯«ç§’çš„æƒ…æ³
  }

  Serial.println("ğŸ¯ å·²å°é½Šæ•´åˆ†é˜èµ·é»");
}

void loop() {
  struct tm timeInfo;

  // âœ… æ¨¡å¼åˆ¤æ–·ï¼šNTP æ¨¡å¼ï¼ˆç²¾æº–ç§’å°é½Šï¼‰æˆ– RTC fallback æ¨¡å¼
  if (ntpSyncedMicros > 0) {
    // ğŸ•’ ä½¿ç”¨ esp_timer ä¾æ“š ntpSyncedTime ç²¾æº–æ¨ç®—ç•¶å‰ UTC ç§’
    while (true) {
      uint64_t nowMicros = esp_timer_get_time();
      uint32_t offset = (nowMicros - ntpSyncedMicros) % 1000000UL;
      if (offset < 1000) break;  // å°é½Šæ¯ç§’èµ·é»
      delayMicroseconds(100);
    }

    uint64_t nowMicros = esp_timer_get_time();
    time_t currentSecond = ntpSyncedTime + ((nowMicros - ntpSyncedMicros) / 1000000ULL);
    localtime_r(&currentSecond, &timeInfo);
  } else {
    // ğŸ•’ RTC æ¨¡å¼ï¼šå¾ DS3231 å–å¾—ç›®å‰æ™‚é–“
    RtcDateTime now = rtc.GetDateTime();
    if (!now.IsValid()) {
      Serial.println("ğŸ›‘ RTC æ™‚é–“ç„¡æ•ˆï¼Œè·³éæ­¤æ¬¡ç™¼æ³¢");
      delay(1000);
      return;
    }

    // âœ¨ è½‰æ›ç‚º struct tm çµæ§‹ï¼ˆé¿å… localtime_r å› æ™‚å€é€ æˆèª¤å·®ï¼‰
    timeInfo.tm_year = now.Year() - 1900;
    timeInfo.tm_mon  = now.Month() - 1;
    timeInfo.tm_mday = now.Day();
    timeInfo.tm_hour = now.Hour();
    timeInfo.tm_min  = now.Minute();
    timeInfo.tm_sec  = now.Second();
    timeInfo.tm_wday = now.DayOfWeek();
  }

  // âœ… LCD é¡¯ç¤ºéƒ¨åˆ†ï¼ˆå›ºå®šè½‰ç‚ºå°ç£æ™‚é–“ +8 é¡¯ç¤ºï¼‰
  int tzHour = timeZoneOffset / 3600;
  time_t baseTime = mktime(&timeInfo);  // æœ¬åœ°æ™‚é–“ï¼ˆNTP/RTCï¼‰è½‰ UTC
  time_t taiwanTime = baseTime - timeZoneOffset + (8 * 3600);  // è£œä¸Šå°ç£æ™‚å€
  struct tm fixedTaiwanTime;
  localtime_r(&taiwanTime, &fixedTaiwanTime);

  // é¡¯ç¤ºç™¼æ³¢ä¾†æºï¼ˆNTP or RTCï¼‰èˆ‡æ™‚é–“
  displayTimeOnLCD(fixedTaiwanTime, timeInfo, ntpSyncedMicros > 0 ? "NTP" : "RTC", tzHour);

  // âœ… å‚³é€å°æ‡‰ç§’çš„ JJY æ™‚ç¢¼
  printAndSendJJY(timeInfo);

  delay(5);  // çŸ­æš«å»¶é²é¿å…é‡è¤‡åŸ·è¡Œ

  // âœ… è‡ªå‹•é‡æ–°å°æ™‚é‚è¼¯
  if (millis() - lastSyncMillis > syncInterval || lastSyncMillis == 0) {
    Serial.printf("â³ è§¸ç™¼é‡æ–°å°æ™‚æª¢æŸ¥ (%lu ms)\n", millis() - lastSyncMillis);
    resyncNTP();
  }
}

void printAndSendJJY(struct tm &timeInfo) {
  // é¡¯ç¤ºç›®å‰ç™¼æ³¢ç§’çš„æ™‚é–“æˆ³
  char buf[64];
  snprintf(buf, sizeof(buf), "â° %04d/%02d/%02d %02d:%02d:%02d",
           timeInfo.tm_year + 1900, timeInfo.tm_mon + 1, timeInfo.tm_mday,
           timeInfo.tm_hour, timeInfo.tm_min, timeInfo.tm_sec);
  Serial.println(buf);

  // âœ… è¨ˆç®—ç•¶å¹´å¾å…ƒæ—¦èµ·çš„å¤©æ•¸ tm_ydayï¼ˆå¾ 0 èµ·ç®—ï¼‰
  static const int daysInMonth[] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
  timeInfo.tm_yday = timeInfo.tm_mday - 1;
  for (int i = 0; i < timeInfo.tm_mon; ++i) {
    timeInfo.tm_yday += daysInMonth[i];
  }

  // è‹¥ç‚ºé–å¹´ä¸”è¶…é 2 æœˆï¼Œè£œåŠ ä¸€å¤©
  int year = timeInfo.tm_year + 1900;
  if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
    if (timeInfo.tm_mon > 1) timeInfo.tm_yday += 1;
  }

  // âœ… è™•ç†é–ç§’ï¼ˆleap secondï¼‰
  int se = timeInfo.tm_sec, sh = 0;
  if (se == 60) {
    sg[53] = LS1 = 1; sg[54] = LS2 = 0; se = 59; sh = 1;
  } else if (se == 61) {
    sg[53] = LS1 = 1; sg[54] = LS2 = 1; se = 58; sh = 2;
  }

  // âœ… å»ºç«‹ sg[] æ™‚ç¢¼è³‡æ–™ï¼ˆBCD ç·¨ç¢¼ + å¥‡å¶æª¢æŸ¥ï¼‰
  set_fix();
  set_min(timeInfo.tm_min);
  set_hour(timeInfo.tm_hour);
  set_day(timeInfo.tm_yday + 1);    // JJY å‚³é€çš„ã€Œæ—¥ã€ç‚ºå¾ 1 èµ·ç®—
  set_wday(timeInfo.tm_wday);
  set_year(year - 2000);            // JJY å¹´æ ¼å¼ç‚ºå…©ä½æ•¸

  // âœ… ç™¼é€ sg[] è³‡æ–™
  Serial.printf("ğŸ“¡ é–‹å§‹ç™¼é€æ™‚é–“ç¢¼ï¼šå¾ %02d ç§’èµ·ï¼Œé è¨ˆé•·åº¦ %d ç§’\n", se, 60 + sh - se);

  char t[64];
  for (int i = se; i < 60 + sh && i < 62; ++i) {
    // ç•°å¸¸å€¼ä¿®æ­£ï¼ˆä¿è­· sg[] ä¸è¢«éŒ¯èª¤æ•¸å€¼ç ´å£ï¼‰
    if (sg[i] != -1 && sg[i] != 0 && sg[i] != 1 && sg[i] != 255) {
      Serial.printf("âš ï¸ sg[%d] å€¼ç•°å¸¸ï¼š%dï¼Œè‡ªå‹•ä¿®æ­£ç‚º 0\n", i, sg[i]);
      sg[i] = 0;
    }

    // å°å‡º sg[i] å€¼
    snprintf(t, sizeof(t), "%02d ", sg[i]);
    Serial.print(t);

    // æ¯ 10 ç­†æ›è¡Œ
    if ((i - se + 1) % 10 == 0) {
      Serial.println();
    }

    // âœ… ç™¼é€å°æ‡‰ PWM æ³¢å½¢
    switch (sg[i]) {
      case -1:
      case 255: mark(); break;
      case 0: zero(); break;
      case 1: one(); break;
    }
  }
}

// â¤ è¨­å®šå¹´ä»½ï¼ˆn ç‚ºå…©ä½æ•¸å¹´ä»½ï¼Œä¾‹å¦‚ 24 ä»£è¡¨ 2024ï¼‰
void set_year(int n){
  int m = dec2BCD(n);
  sg[48] = m % 2; m = m >> 1;
  sg[47] = m % 2; m = m >> 1;
  sg[46] = m % 2; m = m >> 1;
  sg[45] = m % 2; m = m >> 1;
  sg[44] = m % 2; m = m >> 1;
  sg[43] = m % 2; m = m >> 1;
  sg[42] = m % 2; m = m >> 1;
  sg[41] = m % 2;
}

// â¤ è¨­å®šç•¶å¹´çš„ç¬¬å¹¾å¤©ï¼ˆ1~366ï¼‰
void set_day(int n){
  int m = dec2BCD(n);
  sg[33] = m % 2; m = m >> 1;
  sg[32] = m % 2; m = m >> 1;
  sg[31] = m % 2; m = m >> 1;
  sg[30] = m % 2; m = m >> 1;
  sg[28] = m % 2; m = m >> 1;
  sg[27] = m % 2; m = m >> 1;
  sg[26] = m % 2; m = m >> 1;
  sg[25] = m % 2; m = m >> 1;
  sg[23] = m % 2; m = m >> 1;
  sg[22] = m % 2;
}

// â¤ è¨­å®šæ˜ŸæœŸå¹¾ï¼ˆ0~6ï¼Œé€±æ—¥ç‚º 0ï¼‰
void set_wday(int m){
  sg[52] = m % 2; m = m >> 1;
  sg[51] = m % 2; m = m >> 1;
  sg[50] = m % 2;
}

// â¤ è¨­å®šå°æ™‚ï¼ˆ0~23ï¼‰
void set_hour(int n){
  int m = dec2BCD(n);
  sg[18] = m % 2; m = m >> 1;
  sg[17] = m % 2; m = m >> 1;
  sg[16] = m % 2; m = m >> 1;
  sg[15] = m % 2; m = m >> 1;
  sg[13] = m % 2; m = m >> 1;
  sg[12] = m % 2;

  // â• PA1 å¥‡å¶æ ¡é©—ä½
  char PA1 = sg[18] ^ sg[17] ^ sg[16] ^ sg[15] ^ sg[13] ^ sg[12];
  sg[36] = PA1;
}

// â¤ è¨­å®šåˆ†é˜ï¼ˆ0~59ï¼‰
void set_min(int n){
  int m = dec2BCD(n);
  sg[8] = m % 2; m = m >> 1;
  sg[7] = m % 2; m = m >> 1;
  sg[6] = m % 2; m = m >> 1;
  sg[5] = m % 2; m = m >> 1;
  sg[3] = m % 2; m = m >> 1;
  sg[2] = m % 2; m = m >> 1;
  sg[1] = m % 2;

  // â• PA2 å¥‡å¶æ ¡é©—ä½
  char PA2 = sg[8] ^ sg[7] ^ sg[6] ^ sg[5] ^ sg[3] ^ sg[2] ^ sg[1];
  sg[37] = PA2;
}

// â¤ è¨­å®š sg[] å›ºå®šä½ç½®ï¼ˆMæ¨™è¨˜èˆ‡ 0 å€¼æ¬„ä½åˆå§‹åŒ–ï¼‰
void set_fix(){
  sg[0] = sg[9] = sg[19] = sg[29] = sg[39] = sg[49] = sg[59] = M;
  sg[4] = sg[10] = sg[11] = sg[14] = sg[20] = sg[21] =
  sg[24] = sg[34] = sg[35] = sg[55] = sg[56] = sg[57] = sg[58] = 0;
  sg[38] = sg[40] = 0;
  sg[53] = sg[54] = 0;
}

// â¤ å°‡åé€²ä½è½‰ç‚º BCDï¼ˆBinary Coded Decimalï¼‰
int dec2BCD(int decimal) {
  int bcd = 0;
  int multiplier = 1;
  while (decimal > 0) {
    int digit = decimal % 10;
    bcd += digit * multiplier;
    multiplier *= 16;
    decimal /= 10;
  }
  return bcd;
}
// â¤ ç™¼é€ markï¼ˆ0.2 ç§’ on / 0.8 ç§’ offï¼‰
void mark() {
  ledcWrite(ledChannel, 127);
  delay(200);
  ledcWrite(ledChannel, 0);
  delay(800);
}

// â¤ ç™¼é€ 0ï¼ˆ0.8 ç§’ on / 0.2 ç§’ offï¼‰
void zero() {
  ledcWrite(ledChannel, 127);
  delay(800);
  ledcWrite(ledChannel, 0);
  delay(200);
}

// â¤ ç™¼é€ 1ï¼ˆ0.5 ç§’ on / 0.5 ç§’ offï¼‰
void one() {
  ledcWrite(ledChannel, 127);
  delay(500);
  ledcWrite(ledChannel, 0);
  delay(500);
}


// ğŸ“º å°‡ç›®å‰æ™‚é–“è³‡è¨Šé¡¯ç¤ºæ–¼ LCD è¢å¹•ä¸Šï¼ˆæ¯ç§’æ›´æ–°ï¼‰
// fixedTaiwanTimeï¼šå›ºå®šé¡¯ç¤ºå°ç£æ™‚é–“ï¼ˆUTC+8ï¼‰
// rawTimeInfoï¼šå¯¦éš›ç™¼æ³¢æ™‚é–“ï¼ˆNTP æˆ– RTCï¼‰
// sourceLabelï¼šä¾†æºæ¨™ç±¤ï¼ˆNTP æˆ– RTCï¼‰
// tzHourï¼šä½¿ç”¨è€…è¨­å®šçš„æ™‚å€ï¼ˆå¦‚ +8 æˆ– +9ï¼‰

void displayTimeOnLCD(const struct tm &fixedTaiwanTime,
                      const struct tm &rawTimeInfo,
                      const char* sourceLabel,
                      int tzHour) {
// å–å¾—æ˜ŸæœŸç¸®å¯«
const char* weekdayStr[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };

  lcd.clear();
  
// ç¬¬ 1 è¡Œï¼š2025/05/12[NTP]
lcd.setCursor(0, 0);  // ä¸éœ€è¦åç§»
lcd.print(fixedTaiwanTime.tm_year + 1900);
lcd.print("/");
lcd.print(fixedTaiwanTime.tm_mon + 1 < 10 ? "0" : "");
lcd.print(fixedTaiwanTime.tm_mon + 1);
lcd.print("/");
lcd.print(fixedTaiwanTime.tm_mday < 10 ? "0" : "");
lcd.print(fixedTaiwanTime.tm_mday);
lcd.print(" [");
lcd.print(sourceLabel);  // NTP or RTC
lcd.print("]");

// ç¬¬ 2 è¡Œï¼šMon 01:57 (+9)
lcd.setCursor(1, 1);
lcd.print(weekdayStr[fixedTaiwanTime.tm_wday]);  // "Mon"
lcd.print(" ");
lcd.print(fixedTaiwanTime.tm_hour < 10 ? "0" : "");
lcd.print(fixedTaiwanTime.tm_hour);
lcd.print(":");
lcd.print(fixedTaiwanTime.tm_min < 10 ? "0" : "");
lcd.print(fixedTaiwanTime.tm_min);
lcd.print(" (");
lcd.print((tzHour >= 0) ? "+" : "-");
lcd.print(abs(tzHour));
lcd.print(")");
}

void resyncNTP() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("âŒ ç„¡æ³•é‡æ–°å°æ™‚ï¼šWiFi å°šæœªé€£ç·š");
    ntpSyncedMicros = 0;  // åˆ‡å› RTC æ¨¡å¼
    return;
  }

  Serial.println("ğŸ”„ é–‹å§‹é‡æ–°å°æ™‚...");
  configTime(timeZoneOffset, 0, "time.stdtime.gov.tw", "time.google.com", "pool.ntp.org");

  struct tm timeInfo;
  if (getLocalTime(&timeInfo)) {
    Serial.println("ğŸŒ€ getLocalTime() æˆåŠŸï¼Œé‡æ–°åŒæ­¥ NTP æ¨¡å¼");

    time_t ntpEpoch;
    time(&ntpEpoch);
    ntpSyncedMicros = esp_timer_get_time();
    ntpSyncedTime = ntpEpoch;

    delayUntilAlignedRTCWrite();

    RtcDateTime ntpTime(
      timeInfo.tm_year + 1900,
      timeInfo.tm_mon + 1,
      timeInfo.tm_mday,
      timeInfo.tm_hour,
      timeInfo.tm_min,
      timeInfo.tm_sec);
    rtc.SetDateTime(ntpTime);

    Serial.printf("ğŸ” é‡æ–°æ ¡æ™‚æˆåŠŸï¼š%04d/%02d/%02d %02d:%02d:%02d\n",
                  ntpTime.Year(), ntpTime.Month(), ntpTime.Day(),
                  ntpTime.Hour(), ntpTime.Minute(), ntpTime.Second());

    lastSyncMillis = millis();  // æ›´æ–°æˆåŠŸæ™‚é–“
  } else {
    Serial.println("âš ï¸ é‡æ–°å°æ™‚å¤±æ•—ï¼Œåˆ‡æ›å› RTC æ¨¡å¼");
    ntpSyncedMicros = 0;         // åˆ‡å› RTC æ¨¡å¼
  }
}
