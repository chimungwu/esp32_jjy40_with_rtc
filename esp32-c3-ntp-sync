/*
  JJY Transmitter (ver.0.11) - ESP32-C3 SuperMini / NodeMCU-32S Edition
  ---------------------------------------------------------------------
  Based on: ver.0.10 (2024/05/16 by Nash Shuji009)
  Modified by: chimungwu (2025/05/08)

  Target Board: ESP32-C3 SuperMiniï¼ˆé è¨­è¨­å®šï¼‰
  JJY Output: GPIO6 (PWM 40kHz)
  Status LED: GPIO8ï¼ˆé—œé–‰ï¼šæœªç™¼é€ï¼Œé–ƒçˆï¼šç™¼é€ä¸­ï¼‰

  âœ… è‹¥ä½¿ç”¨ ESP32 NodeMCU-32Sï¼Œè«‹ä¾ä¸‹åˆ—æ–¹å¼ä¿®æ”¹è…³ä½èˆ‡ç‹€æ…‹é¡¯ç¤ºï¼š
     - å°‡ PWM è¼¸å‡ºè…³ä½æ”¹ç‚º GPIO26ï¼š const int ledPin = 26;
     - å°‡ç‹€æ…‹ LED è…³ä½æ”¹ç‚º GPIO2ï¼š #define STATUS_LED 2ï¼Œæˆ–æ˜¯ä¾éœ€æ±‚ä¿®æ”¹
  âœ…JJY ç™¼æ³¢ç·šåœˆï¼šæ¥è‡³ GPIO6ï¼Œä¸¦ä¸²è¯ä¸€é¡† 220Î© é›»é˜»å¾Œå†æ¥åˆ°ç·šåœˆã€‚
  âœ…ç‹€æ…‹ LEDï¼šå¯ä½¿ç”¨æ¿è¼‰ LEDï¼ˆGPIO2ï¼‰ï¼Œæˆ–å¤–æ¥ LEDï¼ˆä¸²è¯ 220Î© å¾Œæ¥ GNDï¼‰ã€‚

  == åŠŸèƒ½èªªæ˜ ==
  âœ… æ¯æ¬¡é–‹æ©Ÿéƒ½é€²å…¥ WiFiManagerã€ŒJJY-Setupã€è¨­å®šæ¨¡å¼ï¼Œè®“ä½¿ç”¨è€…è¨­å®š Wi-Fi èˆ‡æ™‚å€
  âœ… ä½¿ç”¨è€…å¯åœ¨è¨­å®šé è¼¸å…¥æ™‚å€ï¼ˆæ ¼å¼å¦‚ +8 æˆ– +9ï¼‰ï¼Œæ”¯æ´è‡ªè¨‚ NTP æ™‚å€æ ¡æ™‚
  âœ… æˆåŠŸé€£ç·š Wi-Fi ä¸¦è¨­å®šå¾Œï¼Œæœƒè‡ªå‹•åŒæ­¥ NTP ä¸¦é–‹å§‹ç™¼é€æ¨¡æ“¬ JJY æ™‚ç¢¼
  âœ… ç™¼æ³¢æ™‚é–“èˆ‡æ—¥æœ¬ JJY é›»æ³¢å°é½Šï¼ˆæ•´åˆ†é˜é–‹å§‹ï¼‰ï¼Œæ¯ç§’å‚³é€ä¸€æ¬¡æ™‚é–“ç¢¼
  âœ… æ”¯æ´é–ç§’èˆ‡éŒ¯èª¤å€¼æª¢æŸ¥ï¼Œç™¼é€çµæŸå¾Œåºåˆ—åŸ æœƒè¼¸å‡ºå‚³é€å…§å®¹

  == æŒ‡ç¤ºç‡ˆç‹€æ…‹ ==
  - å¿«é€Ÿé–ƒçˆï¼šå°šæœªå®Œæˆ NTP å°æ™‚
  - æ¯ç§’é–ƒçˆ1æ¬¡ï¼šNTP å°æ™‚æˆåŠŸï¼Œå·²é–‹å§‹å‚³é€ JJY è¨Šè™Ÿ

  == ç›¸ä¾å‡½å¼åº« ==
  - WiFiManager by tzapu: https://github.com/tzapu/WiFiManager
  - Preferencesï¼ˆå„²å­˜æ™‚å€ï¼‰

  ğŸ“Œ æ™‚å€é è¨­å€¼ç‚º UTC+9ï¼ˆæ—¥æœ¬æ™‚é–“ï¼‰
  âœ è‹¥éœ€æ”¹ç‚ºå°ç£æ™‚é–“ï¼Œè¨­å®šé è«‹è¼¸å…¥ +8
*/


#include <Arduino.h>
#include <driver/ledc.h>
#include <WiFi.h>
#include <WiFiManager.h>
#include <Preferences.h>

// === Hardware Settings ===
const int ledChannel = 0;  // PWM channel for JJY signal output
const int ledPin     = 6;  // PWM output pin (connected to JJY antenna via GPIO6)
#define STATUS_LED    8    // Onboard status LED (GPIO8 on ESP32-C3 SuperMini)

// === JJY Signal Variables ===
char P0, P1, P2, P3, P4, P5;
const char M = P0 = P1 = P2 = P3 = P4 = P5 = -1;  // Marker signal (-1 or 255)
char PA1, PA2;
char SU1, LS1, LS2;
char sg[60];

// === Time Sync Status ===
bool ntpSynced       = true;
unsigned long lastBlink = 0;
bool ledState        = false;

// === Timezone Configuration ===
Preferences prefs;
String tzString = "+9";
long timezoneOffsetSec = 9 * 3600L;

void setup() {
  Serial.begin(115200);
  delay(1000);

  pinMode(STATUS_LED, OUTPUT);
  digitalWrite(STATUS_LED, LOW);

  set_fix();
  ledcSetup(ledChannel, 40000, 8);
  ledcAttachPin(ledPin, ledChannel);

  WiFiManager wm;
  wm.resetSettings();  // <== å¼·åˆ¶æ¸…é™¤
  WiFiManagerParameter tzParam("tz", "Enter timezone (e.g. +8 for Taiwan, default +9 for Japan)", "+9", 4);
  wm.addParameter(&tzParam);

  if (!wm.autoConnect("JJY-Setup")) {
    Serial.println("\nâŒ WiFiManager é€£ç·šå¤±æ•—ï¼Œç„¡æ³•é€²è¡Œ NTP åŒæ­¥");
    ntpSynced = false;
    return;
  }

  Serial.println("\nğŸ“¶ WiFiManager æˆåŠŸé€£ç·š");

  tzString = String(tzParam.getValue());
  prefs.begin("jjy", false);
  prefs.putString("tz", tzString);
  prefs.end();

  int tz_hour = tzString.toInt();
  timezoneOffsetSec = tz_hour * 3600L;
  Serial.printf("ğŸŒ Timezone è¨­å®šç‚º UTC%+d\n", tz_hour);

  configTime(timezoneOffsetSec, 0,
             "time.stdtime.gov.tw", "time.google.com", "ntp.twnic.tw");

  struct tm timeInfo;
  int retries = 0;

  Serial.print("â³ Synchronizing time via NTP");
  while (!getLocalTime(&timeInfo) && retries < 10) {
    delay(500);
    Serial.print(".");
    retries++;
  }

  if (getLocalTime(&timeInfo)) {
    ntpSynced = true;
    Serial.println("\nâœ… NTP time synchronized successfully.");

    char timeStr[64];
    sprintf(timeStr, "ğŸ•’ Current Time: %04d-%02d-%02d %02d:%02d:%02d",
            timeInfo.tm_year + 1900, timeInfo.tm_mon + 1, timeInfo.tm_mday,
            timeInfo.tm_hour, timeInfo.tm_min, timeInfo.tm_sec);
    Serial.println(timeStr);
  } else {
    Serial.println("\nâŒ Failed to synchronize time via NTP.");
    ntpSynced = false;
  }
}


void delayUntilAlignedRTCWrite() {
  struct timeval tv;
  gettimeofday(&tv, NULL);

  int64_t micros_now = tv.tv_sec * 1000000LL + tv.tv_usec;
  int64_t micros_next_minute = ((tv.tv_sec / 60) + 1) * 60 * 1000000LL;

  int64_t delay_us = micros_next_minute - micros_now;

  Serial.printf("â± å°é½Šå»¶é² %.3f ç§’...\n", delay_us / 1000000.0);

  if (delay_us >= 1000) {
    delay(delay_us / 1000);                  // æ¯«ç§’ä»¥ä¸Šéƒ¨åˆ†
    delayMicroseconds(delay_us % 1000);      // å‰©ä¸‹å¾®ç§’
  } else {
    delayMicroseconds(delay_us);
  }
}

bool hasAligned = false;  // â± åªåœ¨ç¬¬ä¸€æ¬¡å°é½Š

void loop() {
  // ç‹€æ…‹ç‡ˆé‚è¼¯ï¼šåŒæ­¥æˆåŠŸ â†’ å¸¸äº®ï¼›æœªåŒæ­¥ â†’ æ¯ç§’é–ƒçˆ
  if (!ntpSynced) {
    if (millis() - lastBlink >= 500) {
      ledState = !ledState;
      digitalWrite(STATUS_LED, ledState ? HIGH : LOW);
      lastBlink = millis();
    }
  }

  // æ™‚ç¢¼ç™¼é€é‚è¼¯
  if (ntpSynced) {
    if (!hasAligned) {
      delayUntilAlignedRTCWrite();  // â± ç¬¬ä¸€æ¬¡é€²å…¥æ™‚å°é½Šæ•´åˆ†é˜
      hasAligned = true;
    }
    printAndSendJJY();  // ç™¼é€å®Œæ•´ä¸€åˆ†é˜çš„ JJY æ™‚ç¢¼
  } else {
    delay(1000);  // å°šæœªåŒæ­¥æ™‚ï¼Œå»¶é²ç­‰å¾… WiFi/NTP é‡å•Ÿ
  }
}


void set_year(int n){
  
  int m = dec2BCD(n);

  sg[48] = m % 2; m = m >> 1;
  sg[47] = m % 2; m = m >> 1;
  sg[46] = m % 2; m = m >> 1;
  sg[45] = m % 2; m = m >> 1;

  sg[44] = m % 2; m = m >> 1;
  sg[43] = m % 2; m = m >> 1;
  sg[42] = m % 2; m = m >> 1;
  sg[41] = m % 2;
}

void printAndSendJJY() {
  struct tm timeInfo;
  char s[40];
  char t[64];
  int se, mi, sh;

  getLocalTime(&timeInfo);

  sprintf(s, "%04d/%02d/%02d %02d:%02d:%02d",
          timeInfo.tm_year + 1900, timeInfo.tm_mon + 1, timeInfo.tm_mday,
          timeInfo.tm_hour, timeInfo.tm_min, timeInfo.tm_sec);
  Serial.println(s);

  sprintf(t, "Y:%02d  D:%03d WD:%01d",
          timeInfo.tm_year + 1900 - 2000, timeInfo.tm_yday + 1, timeInfo.tm_wday);
  Serial.println(t);

  // é–ç§’è£œæ­£
  se = timeInfo.tm_sec;
  sh = 0;
  if (timeInfo.tm_sec == 60) {
    sg[53] = LS1 = 1;
    sg[54] = LS2 = 0;
    se = timeInfo.tm_sec - 1;
    sh = 1;
  }
  if (timeInfo.tm_sec == 61) {
    sg[53] = LS1 = 1;
    sg[54] = LS2 = 1;
    se = timeInfo.tm_sec - 2;
    sh = 2;
  }

  set_min(timeInfo.tm_min);
  set_hour(timeInfo.tm_hour);
  set_day(timeInfo.tm_yday + 1);
  set_wday(timeInfo.tm_wday);
  set_year(timeInfo.tm_year + 1900 - 2000);

  for (int i = se; i < 60 + sh; i++) {

    // ç‹€æ…‹ç‡ˆé–ƒçˆï¼ˆæ¯ç§’ï¼‰
    if (millis() - lastBlink >= 1000) {
      ledState = !ledState;
      digitalWrite(STATUS_LED, ledState ? HIGH : LOW);
      lastBlink = millis();
    }

    sprintf(t, "%02d ", sg[i]);
    Serial.print(t);
    switch (sg[i]) {
      case -1:
      case 255:
        mark();
        break;
      case 0:
        zero();
        break;
      case 1:
        one();
        break;
      default:
        zero();
        sprintf(t, "%02d  %02d", i, sg[i]);
        Serial.print("***BUG data ***  ");
        Serial.println(t);
        break;
    }
  }
}

void set_day(int n){
  
  int m = dec2BCD(n);

  sg[33] = m % 2; m = m >> 1;
  sg[32] = m % 2; m = m >> 1;
  sg[31] = m % 2; m = m >> 1;
  sg[30] = m % 2; m = m >> 1;

  sg[28] = m % 2; m = m >> 1;
  sg[27] = m % 2; m = m >> 1;
  sg[26] = m % 2; m = m >> 1;
  sg[25] = m % 2; m = m >> 1;

  sg[23] = m % 2; m = m >> 1;
  sg[22] = m % 2;
}

void set_wday(int m){

  sg[52] = m % 2; m = m >> 1;
  sg[51] = m % 2; m = m >> 1;
  sg[50] = m % 2;
}

void set_hour(int n){
  
  int m = dec2BCD(n);

  sg[18] = m % 2; m = m >> 1;
  sg[17] = m % 2; m = m >> 1;
  sg[16] = m % 2; m = m >> 1;
  sg[15] = m % 2; m = m >> 1;
  
  sg[13] = m % 2; m = m >> 1;
  sg[12] = m % 2;
  
  char PA1 = sg[18] ^ sg[17] ^ sg[16] ^ sg[15] ^ sg[13] ^ sg[12]; //PA1 = (20h+10h+8h+4h+2h+1h) mod 2
  sg[36] = PA1;
}

void set_min(int n){
  
  int m = dec2BCD(n);


  sg[8] = m % 2; m = m >> 1;
  sg[7] = m % 2; m = m >> 1;
  sg[6] = m % 2; m = m >> 1;
  sg[5] = m % 2; m = m >> 1;

  sg[3] = m % 2; m = m >> 1;
  sg[2] = m % 2; m = m >> 1;
  sg[1] = m % 2;

  char PA2 = sg[8] ^ sg[7] ^ sg[6] ^ sg[5] ^ sg[3] ^ sg[2] ^ sg[1]; //PA2 = (40m+20m+10m+8m+4m+2m+1m) mod 2
  sg[37] = PA2;
}


void set_fix(){
  sg[0] = sg[9] = sg[19] = sg[29] = sg[39] = sg[49] = sg[59] = M;
  sg[4] = sg[10] = sg[11] = sg[14] = sg[20] = sg[21] = sg[24] = sg[34] = sg[35] = sg[55] = sg[56] = sg[57] = sg[58] = 0;
  sg[38] = sg[40] = 0;
  sg[53] = sg[54] = 0;
  
}

int dec2BCD(int decimal) {
    int bcd = 0;
    int multiplier = 1;

    while (decimal > 0) {
        int digit = decimal % 10;
        bcd += digit * multiplier;
        multiplier *= 16; // 10é€²æ•°ã®å„æ¡ã‚’4ãƒ“ãƒƒãƒˆã®BCDã«å¤‰æ›ã™ã‚‹ãŸã‚ã«16å€ã™ã‚‹
        decimal /= 10;
    }

    return bcd;
    
    ///printf("BCD: %X\n", bcd);
}


void mark() {   // 0.2sec
  ledcWrite(ledChannel, 127);
  delay(200);
  ledcWrite(ledChannel, 0);
  delay(800);
}

void zero() {  // 0.8sec
  ledcWrite(ledChannel, 127);
  delay(800);
  ledcWrite(ledChannel, 0);
  delay(200);
}

void one() {    // 0.5sec
  ledcWrite(ledChannel, 127);
  delay(500);
  ledcWrite(ledChannel, 0);
  delay(500);
}
