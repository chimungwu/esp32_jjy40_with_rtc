/*
  JJY Transmitter (ver.0.11) - ESP32-C3 SuperMini Edition
  ---------------------------------------------------------
  Based on: ver.0.10 (2024/05/16 by Nash Shuji009)
  Modified by: chimungwu (2025/05/07)
  Target Board: ESP32-C3 SuperMini
  JJY Output: GPIO6 (PWM 40kHz)
  Status LED: GPIO8 (blinks during transmission)

  == Change Summary (ver.0.11) ==
  ‚úÖ Ported to ESP32-C3 SuperMini with updated GPIO settings
  ‚úÖ Integrated WiFiManager library for dynamic Wi-Fi setup via captive portal (SSID: "JJY-Setup")
  ‚úÖ Added automatic NTP synchronization with retry and timezone support (UTC+9 by default)
  ‚úÖ Implemented microsecond-precision alignment using esp_timer (transmission aligns to top of minute)
  ‚úÖ Modularized code structure: moved transmission logic to printAndSendJJY()
  ‚úÖ Status LED now blinks once per second while transmitting (if NTP synced)
  ‚úÖ Added leap second compensation and basic signal validation handling
  ‚úÖ Serial debug output improved for clarity

  Libraries required:
    - WiFiManager by tablatronix: https://github.com/tzapu/WiFiManager

  Note:
    Default timezone is set to Japan Standard Time (UTC+9).
    To use Taiwan time, change TIMEZONE_OFFSET_SEC to (8 * 3600L).
*/

#include <Arduino.h>
#include <driver/ledc.h>
#include <WiFi.h>
#include <WiFiManager.h> 

// === Hardware Settings ===
const int ledChannel = 0;  // PWM channel for JJY signal output
const int ledPin     = 6;  // PWM output pin (connected to JJY antenna via GPIO6)
#define STATUS_LED    8    // Onboard status LED (GPIO8 on ESP32-C3 SuperMini)

// === JJY Signal Variables ===
char P0, P1, P2, P3, P4, P5;
const char M = P0 = P1 = P2 = P3 = P4 = P5 = -1;  // Marker signal (-1 or 255)
char PA1, PA2;                                   // Parity bits
char SU1, LS1, LS2;                              // Special flags (e.g., leap second)
char sg[60];                                     // Signal data buffer (1 minute)

// === WiFi Settings ===
const char* ssid     = "SSID";        // Replace with your Wi-Fi SSID
const char* password = "PASSWORD";  // Replace with your Wi-Fi password

// === Time Sync Status ===
bool ntpSynced       = false;          // Set to true if NTP sync succeeds
unsigned long lastBlink = 0;          // Last LED toggle time
bool ledState        = false;         // LED on/off flag

// === Timezone Configuration ===
#define TIMEZONE_OFFSET_SEC (9 * 3600L)  // UTC+9 (Japan Standard Time)
                                         // Use 8 * 3600L for Taiwan (UTC+8)
void setup() {
  Serial.begin(115200);
  delay(1000);

  pinMode(STATUS_LED, OUTPUT);
  digitalWrite(STATUS_LED, LOW);

  set_fix();
  ledcSetup(ledChannel, 40000, 8);
  ledcAttachPin(ledPin, ledChannel);

  // ÂÑ™ÂÖà‰ΩøÁî®È†êË®≠ SSID/PASSWORD ÂòóË©¶ÈÄ£Á∑ö
  Serial.println("üì∂ ÂòóË©¶ÈÄ£Êé•È†êË®≠ WiFi...");
  WiFi.begin(ssid, password);

  unsigned long startAttemptTime = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - startAttemptTime < 10000) {
    delay(500);
    Serial.print(".");
  }

  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("\n‚ö†Ô∏è È†êË®≠ WiFi ÈÄ£Á∑öÂ§±ÊïóÔºåÈÄ≤ÂÖ• WiFiManager Ê®°Âºè");

    WiFiManager wm;
    wm.setTimeout(60); // ÊúÄÂ§öÁ≠âÂæÖ 1 ÂàÜÈêò
    bool res = wm.autoConnect("JJY-Setup");

    if (!res) {
      Serial.println("‚ùå Failed to connect and timeout occurred.");
      ntpSynced = false;
      return;
    }

    Serial.println("üì∂ WiFi connected via Captive Portal.");
  } else {
    Serial.println("\n‚úÖ ÊàêÂäüÈÄ£‰∏äÈ†êË®≠ WiFi");
  }

  digitalWrite(STATUS_LED, HIGH);

  // ‚≠ê ‰∏çË´ñÂì™Á®ÆÊñπÂºèÈÄ£‰∏ä WiFiÔºåÈÉΩÈÄ≤Ë°å NTP ÂêåÊ≠•
  configTime(TIMEZONE_OFFSET_SEC, 0, 
             "time.stdtime.gov.tw", "time.google.com", "ntp.twnic.tw");

  struct tm timeInfo;
  int retries = 0;

  Serial.print("‚è≥ Synchronizing time via NTP");
  while (!getLocalTime(&timeInfo) && retries < 10) {
    delay(500);
    Serial.print(".");
    retries++;
  }

  if (getLocalTime(&timeInfo)) {
    ntpSynced = true;
    Serial.println("\n‚úÖ NTP time synchronized successfully.");

    char timeStr[64];
    sprintf(timeStr, "üïí Current Time: %04d-%02d-%02d %02d:%02d:%02d",
            timeInfo.tm_year + 1900, timeInfo.tm_mon + 1, timeInfo.tm_mday,
            timeInfo.tm_hour, timeInfo.tm_min, timeInfo.tm_sec);
    Serial.println(timeStr);

    int tz_hour = TIMEZONE_OFFSET_SEC / 3600;
    Serial.printf("üåê Timezone: UTC%+d\n", tz_hour);
  } else {
    Serial.println("\n‚ùå Failed to synchronize time via NTP.");
    ntpSynced = false;
  }
}


void delayUntilAlignedRTCWrite() {
  struct timeval tv;
  gettimeofday(&tv, NULL);

  int64_t micros_now = tv.tv_sec * 1000000LL + tv.tv_usec;
  int64_t micros_next_minute = ((tv.tv_sec / 60) + 1) * 60 * 1000000LL;

  int64_t delay_us = micros_next_minute - micros_now;

  Serial.printf("‚è± Â∞çÈΩäÂª∂ÈÅ≤ %.3f Áßí...\n", delay_us / 1000000.0);

  if (delay_us >= 1000) {
    delay(delay_us / 1000);                  // ÊØ´Áßí‰ª•‰∏äÈÉ®ÂàÜ
    delayMicroseconds(delay_us % 1000);      // Ââ©‰∏ãÂæÆÁßí
  } else {
    delayMicroseconds(delay_us);
  }
}

bool hasAligned = false;  // ‚è± Âè™Âú®Á¨¨‰∏ÄÊ¨°Â∞çÈΩä

void loop() {

  if (ntpSynced) {
    if (!hasAligned) {
      delayUntilAlignedRTCWrite();  // ‚è± Âè™ÂÅö‰∏ÄÊ¨°
      hasAligned = true;
    }
    printAndSendJJY();  // ÊØèÂàÜÈêòÁôºÈÄÅÊôÇÁ¢º
  } else {
    delay(1000); // Ëã•Êú™ÂêåÊ≠•ÔºåÈÅøÂÖçÈ†ªÁπÅÈáçË©¶
  }
}

void waitForNextSecondAligned() {
  uint64_t nowMicros = esp_timer_get_time();
  uint64_t offset = nowMicros % 1000000UL;

  while (offset > 1000) {  // ÂÅúÂà∞‰∏ã‰∏ÄÂÄãÁßíËµ∑Èªû ¬±1ms
    delayMicroseconds(100);
    nowMicros = esp_timer_get_time();
    offset = nowMicros % 1000000UL;
  }
}

void set_year(int n){
  
  int m = dec2BCD(n);

  sg[48] = m % 2; m = m >> 1;
  sg[47] = m % 2; m = m >> 1;
  sg[46] = m % 2; m = m >> 1;
  sg[45] = m % 2; m = m >> 1;

  sg[44] = m % 2; m = m >> 1;
  sg[43] = m % 2; m = m >> 1;
  sg[42] = m % 2; m = m >> 1;
  sg[41] = m % 2;
}

void printAndSendJJY() {
  struct tm timeInfo;
  char s[40];
  char t[64];
  int se, mi, sh;

  getLocalTime(&timeInfo);

  sprintf(s, "%04d/%02d/%02d %02d:%02d:%02d",
          timeInfo.tm_year + 1900, timeInfo.tm_mon + 1, timeInfo.tm_mday,
          timeInfo.tm_hour, timeInfo.tm_min, timeInfo.tm_sec);
  Serial.println(s);

  sprintf(t, "Y:%02d  D:%03d WD:%01d",
          timeInfo.tm_year + 1900 - 2000, timeInfo.tm_yday + 1, timeInfo.tm_wday);
  Serial.println(t);

  // ÈñèÁßíË£úÊ≠£
  se = timeInfo.tm_sec;
  sh = 0;
  if (timeInfo.tm_sec == 60) {
    sg[53] = LS1 = 1;
    sg[54] = LS2 = 0;
    se = timeInfo.tm_sec - 1;
    sh = 1;
  }
  if (timeInfo.tm_sec == 61) {
    sg[53] = LS1 = 1;
    sg[54] = LS2 = 1;
    se = timeInfo.tm_sec - 2;
    sh = 2;
  }

  set_min(timeInfo.tm_min);
  set_hour(timeInfo.tm_hour);
  set_day(timeInfo.tm_yday + 1);
  set_wday(timeInfo.tm_wday);
  set_year(timeInfo.tm_year + 1900 - 2000);

for (int i = se; i < 60 + sh; i++) {

  waitForNextSecondAligned();  // ‚úÖ ÊØèÁßíÁôºÈÄÅÂâçÂÖàÂ∞çÈΩäÂà∞Êñ∞ÁöÑ‰∏ÄÁßí 0ms

  // ÁãÄÊÖãÁáàÈñÉÁàçÔºàÊØèÁßíÔºâ
  if (millis() - lastBlink >= 1000) {
    ledState = !ledState;
    digitalWrite(STATUS_LED, ledState ? HIGH : LOW);
    lastBlink = millis();
  }

  sprintf(t, "%02d ", sg[i]);
  Serial.print(t);
  if ((i - se + 1) % 10 == 0) Serial.println();

  switch (sg[i]) {
    case -1:
    case 255: mark(); break;
    case 0:    zero(); break;
    case 1:    one(); break;
    default:
      zero();
      Serial.printf("***BUG data*** sg[%02d] = %02d\n", i, sg[i]);
      break;
  }
}

}

void set_day(int n){
  
  int m = dec2BCD(n);

  sg[33] = m % 2; m = m >> 1;
  sg[32] = m % 2; m = m >> 1;
  sg[31] = m % 2; m = m >> 1;
  sg[30] = m % 2; m = m >> 1;

  sg[28] = m % 2; m = m >> 1;
  sg[27] = m % 2; m = m >> 1;
  sg[26] = m % 2; m = m >> 1;
  sg[25] = m % 2; m = m >> 1;

  sg[23] = m % 2; m = m >> 1;
  sg[22] = m % 2;
}

void set_wday(int m){

  sg[52] = m % 2; m = m >> 1;
  sg[51] = m % 2; m = m >> 1;
  sg[50] = m % 2;
}

void set_hour(int n){
  
  int m = dec2BCD(n);

  sg[18] = m % 2; m = m >> 1;
  sg[17] = m % 2; m = m >> 1;
  sg[16] = m % 2; m = m >> 1;
  sg[15] = m % 2; m = m >> 1;
  
  sg[13] = m % 2; m = m >> 1;
  sg[12] = m % 2;
  
  char PA1 = sg[18] ^ sg[17] ^ sg[16] ^ sg[15] ^ sg[13] ^ sg[12]; //PA1 = (20h+10h+8h+4h+2h+1h) mod 2
  sg[36] = PA1;
}

void set_min(int n){
  
  int m = dec2BCD(n);


  sg[8] = m % 2; m = m >> 1;
  sg[7] = m % 2; m = m >> 1;
  sg[6] = m % 2; m = m >> 1;
  sg[5] = m % 2; m = m >> 1;

  sg[3] = m % 2; m = m >> 1;
  sg[2] = m % 2; m = m >> 1;
  sg[1] = m % 2;

  char PA2 = sg[8] ^ sg[7] ^ sg[6] ^ sg[5] ^ sg[3] ^ sg[2] ^ sg[1]; //PA2 = (40m+20m+10m+8m+4m+2m+1m) mod 2
  sg[37] = PA2;
}


void set_fix(){
  sg[0] = sg[9] = sg[19] = sg[29] = sg[39] = sg[49] = sg[59] = M;
  sg[4] = sg[10] = sg[11] = sg[14] = sg[20] = sg[21] = sg[24] = sg[34] = sg[35] = sg[55] = sg[56] = sg[57] = sg[58] = 0;
  sg[38] = sg[40] = 0;
  sg[53] = sg[54] = 0;
  
}

int dec2BCD(int decimal) {
    int bcd = 0;
    int multiplier = 1;

    while (decimal > 0) {
        int digit = decimal % 10;
        bcd += digit * multiplier;
        multiplier *= 16; // 10ÈÄ≤Êï∞„ÅÆÂêÑÊ°Å„Çí4„Éì„ÉÉ„Éà„ÅÆBCD„Å´Â§âÊèõ„Åô„Çã„Åü„ÇÅ„Å´16ÂÄç„Åô„Çã
        decimal /= 10;
    }

    return bcd;
    
    ///printf("BCD: %X\n", bcd);
}


void mark() {   // 0.2sec
  ledcWrite(ledChannel, 127);
  delay(200);
  ledcWrite(ledChannel, 0);
  delay(800);
}

void zero() {  // 0.8sec
  ledcWrite(ledChannel, 127);
  delay(800);
  ledcWrite(ledChannel, 0);
  delay(200);
}

void one() {    // 0.5sec
  ledcWrite(ledChannel, 127);
  delay(500);
  ledcWrite(ledChannel, 0);
  delay(500);
}
