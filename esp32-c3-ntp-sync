/*
  JJY Transmitter - ESP32-C3 SuperMini / NodeMCU-32S Edition
  ---------------------------------------------------------------------
  Based on: ver.0.10 (2024/05/16 by Nash Shuji009)
  Modified by: chimungwu (2025/05/17)

  â–¶ é©ç”¨é–‹ç™¼æ¿ï¼š
    - ESP32-C3 SuperMiniï¼ˆé è¨­è…³ä½ï¼‰
    - æˆ– ESP32 NodeMCU-32Sï¼ˆéœ€èª¿æ•´è…³ä½ï¼‰

  â–¶ è¼¸å‡ºè¨­å®šï¼š
    - JJY è¼¸å‡ºï¼šGPIO7ï¼ˆé è¨­ï¼ŒPWM 40kHzï¼‰
    - ç‹€æ…‹ LEDï¼šGPIO8ï¼ˆé è¨­ï¼ŒHIGH = ç™¼æ³¢ä¸­ï¼‰

  â–¶ ä½¿ç”¨èªªæ˜ï¼š
    âœ… æ¯æ¬¡é–‹æ©Ÿè‡ªå‹•é€²å…¥ WiFiManagerã€ŒJJY-Setupã€ä»‹é¢ï¼Œè¨­å®š Wi-Fi èˆ‡æ™‚å€
    âœ… å¯è¼¸å…¥æ™‚å€ï¼ˆæ ¼å¼å¦‚ +8 æˆ– +9ï¼‰ä¸¦è¨­å®šè‡ªå‹•é‡æ–°å°æ™‚é–“éš”ï¼ˆ1~24 å°æ™‚ï¼‰
    âœ… æˆåŠŸé€£ç·š Wi-Fi å¾Œæœƒé€é NTP å°æ™‚ï¼Œä¸¦å°é½Šæ•´åˆ†é˜é–‹å§‹ç™¼é€æ¨¡æ“¬ JJY é›»æ³¢
    âœ… ç™¼æ³¢é »ç‡ç‚º 40kHzï¼ˆæ—¥æœ¬æ¨™æº– JJYï¼‰ï¼Œæ¯ç§’å‚³é€ä¸€å€‹æ™‚é–“ç¢¼ä½å…ƒ
    âœ… æ”¯æ´é–ç§’è£œæ­£èˆ‡ sg[] è³‡æ–™ç•°å¸¸æª¢æŸ¥ï¼Œå‚³é€å…§å®¹æœƒè¼¸å‡ºè‡³åºåˆ—åŸ 
    âœ… æ¯ç§’ LED é–ƒçˆæç¤ºç™¼æ³¢é€²è¡Œä¸­ï¼ŒWiFi è¨­å®šå¤±æ•—æ™‚è‡ªå‹• fallback ç‚ºåŸè¨­å®š

  â–¶ LED ç‹€æ…‹æç¤ºï¼š
    - é–‹æ©Ÿå¿«é€Ÿé–ƒçˆ 15 ç§’
    - è¨­å®šæ¨¡å¼ï¼šå¸¸äº®ï¼ˆç­‰å¾… WiFiManager è¨­å®šï¼‰
    - ç™¼æ³¢ä¸­ï¼šæ¯ç§’é–ƒçˆä¸€æ¬¡ï¼ˆNTP åŒæ­¥æˆåŠŸï¼‰

  â–¶ ç›¸ä¾å‡½å¼åº«ï¼š
    - WiFiManager by tzapu: https://github.com/tzapu/WiFiManager
    
  â–¶ ç¡¬é«”é€£æ¥èªªæ˜ï¼š
    - ç™¼æ³¢ç·šåœˆæ¥ GPIO7ï¼Œä¸¦ä¸²æ¥ä¸€é¡† 220Î© é›»é˜»è‡³ GND
    - ç‹€æ…‹ LED æ¥ GPIO8ï¼ˆå»ºè­°ä¸²è¯ 220Î© åˆ° GNDï¼‰ï¼Œæˆ–ä½¿ç”¨æ¿è¼‰ LED

  âš ï¸ æ³¨æ„ï¼šESP32-C3 è‹¥è¦ä½¿ç”¨ Serial Monitorï¼ˆåºåˆ—åŸ ç›£æ§ï¼‰è§€å¯Ÿè¼¸å‡º
    â¤ è«‹å‹™å¿…åœ¨ Arduino IDE çš„ Tools é¸å–®ä¸­å•Ÿç”¨ï¼š
        Tools â†’ USB CDC on Boot â†’ Enabled
    â¤ ä¸¦é¸æ“‡æ³¢ç‰¹ç‡ 115200ï¼Œæ‰èƒ½æ­£ç¢ºçœ‹åˆ° Serial.println() çš„è¼¸å‡º

  ğŸ“Œ é è¨­æ™‚å€ç‚º UTC+9ï¼ˆæ—¥æœ¬æ™‚é–“ï¼‰
    â¤ è‹¥éœ€æ”¹ç‚ºå°ç£æ™‚é–“ï¼Œè¨­å®šé è«‹è¼¸å…¥ +8
*/

#include <Arduino.h>
#include <driver/ledc.h>
#include <WiFi.h>
#include <WiFiManager.h>
#include <Preferences.h>
#include <sys/time.h>

uint64_t ntpSyncedMicros = 0;
time_t ntpSyncedTime = 0;

// === Hardware Settings ===
const int ledChannel = 0;  // PWM channel for JJY signal output
const int ledPin     = 7;  // PWM output pin (connected to JJY antenna via GPIO7)
#define STATUS_LED    8    // Onboard status LED (GPIO8 on ESP32-C3 SuperMini)

// === JJY Signal Variables ===
char P0, P1, P2, P3, P4, P5;
const char M = P0 = P1 = P2 = P3 = P4 = P5 = -1;  // Marker signal (-1 or 255)
char SU1, LS1, LS2;
char sg[62];

// === Time Sync Status ===
bool ntpSynced       = false;
unsigned long lastBlink = 0;
bool ledState        = false;

// === Timezone Configuration ===
Preferences prefs;
String tzString = "+9";
long timezoneOffsetSec = 9 * 3600L;

// === NTP è‡ªå‹•é‡æ–°å°æ™‚è¨­å®š ===
unsigned long lastSyncMillis = 0;         // ä¸Šæ¬¡å°æ™‚çš„æ™‚é–“ï¼ˆmillisï¼‰
int autoSyncHour = 6;                     // é è¨­è‡ªå‹•å°æ™‚é–“é–“éš”ï¼ˆå°æ™‚ï¼‰
unsigned long syncInterval = 6UL * 60UL * 60UL * 1000UL;  // æ›ç®—ç‚ºæ¯«ç§’


void setup() {
  Serial.begin(115200);   // ğŸ”ºæå‰å•Ÿå‹•åºåˆ—åŸ 
  Serial.println("ğŸ”§ å•Ÿå‹• WiFi è¨­å®šä»‹é¢ä¸­...");
    
  pinMode(STATUS_LED, OUTPUT);
  digitalWrite(STATUS_LED, LOW);
  
  set_fix();
  ledcSetup(ledChannel, 40000, 8);
  ledcAttachPin(ledPin, ledChannel);

// ä¸€é–‹æ©Ÿå…ˆé–ƒçˆ 15 ç§’

unsigned long blinkStart = millis();
while (millis() - blinkStart < 15000) {
  if (millis() - lastBlink >= 300) {
    ledState = !ledState;
    digitalWrite(STATUS_LED, ledState ? HIGH : LOW);
    lastBlink = millis();
  }
  delay(10);
}
// é–ƒå®Œå¾Œæ†äº®
  digitalWrite(STATUS_LED, HIGH);
  delay(1000);

//ä½¿ç”¨WiFiManagerè¨­å®šç¶²è·¯åŠæ™‚å€
  WiFiManager wm;
  WiFiManagerParameter tzParam("tz", "Enter timezone (e.g. +8 for Taiwan)", "+9", 4);
  WiFiManagerParameter syncParam("sync", "Auto Sync Interval (hr)", "6", 3);
  wm.addParameter(&tzParam);
  wm.addParameter(&syncParam);
  
  wm.setConfigPortalTimeout(30);  // æœ€å¤šç­‰å¾… 30 ç§’è¨­å®š
  wm.startConfigPortal("JJY-Setup");  // å•Ÿå‹•è¨­å®šä»‹é¢ï¼ˆéé˜»å¡ï¼‰
  unsigned long configStart = millis();

  while (!wm.getWiFiIsSaved() && (millis() - configStart < 20000)) {
    wm.process();       // éé˜»å¡è™•ç† WiFiManager
    delay(100);
  }
    
    WiFi.mode(WIFI_STA);
    WiFi.begin();

unsigned long connectStart = millis();
while (WiFi.status() != WL_CONNECTED && millis() - connectStart < 10000) {
  delay(500);
  Serial.print(".");
}

  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("\nâŒ WiFi è¨­å®šé€¾æ™‚ï¼Œç„¡æ³•é€£ç·š");
    ntpSynced = false;
    return;
  }

  Serial.println("\nğŸ“¶ WiFi é€£ç·šæˆåŠŸ");

  // æ“·å–æ™‚å€èˆ‡è‡ªå‹•åŒæ­¥é–“éš”è¨­å®š
tzString = String(tzParam.getValue());
prefs.begin("jjy", false);
prefs.putString("tz", tzString);
prefs.end();

int tz_hour = tzString.toInt();
timezoneOffsetSec = tz_hour * 3600L;
Serial.printf("ğŸŒ Timezone è¨­å®šç‚º UTC%+d\n", tz_hour);

// âœ… è§£æ sync æ™‚é–“
const char* syncInput = syncParam.getValue();
if (syncInput && strlen(syncInput) > 0) {
  int hr = atoi(syncInput);
  if (hr >= 1 && hr <= 24) {  // åˆç†ç¯„åœæª¢æŸ¥
    autoSyncHour = hr;
    syncInterval = (unsigned long)hr * 60UL * 60UL * 1000UL;
    Serial.printf("ğŸ” è‡ªå‹•æ ¡æ™‚é–“éš”ï¼šæ¯ %d å°æ™‚\n", autoSyncHour);
  }
}

  configTime(timezoneOffsetSec, 0,
             "time.stdtime.gov.tw", "time.google.com", "ntp.twnic.tw");

  struct tm timeInfo;
  int retries = 0;

  Serial.print("â³ æ­£åœ¨é€é NTP åŒæ­¥æ™‚é–“");
  while (!getLocalTime(&timeInfo) && retries < 10) {
    if (millis() - lastBlink >= 300) {
      ledState = !ledState;
      digitalWrite(STATUS_LED, ledState ? HIGH : LOW);
      lastBlink = millis();
    }
    delay(10);
    retries++;
  }

  if (getLocalTime(&timeInfo)) {
    ntpSynced = true;
    // æ–°å¢ï¼šç´€éŒ„ç²¾æº–å°æ™‚æ™‚é–“é»ï¼ˆç§’ + å¾®ç§’ï¼‰
    time(&ntpSyncedTime);
    ntpSyncedMicros = esp_timer_get_time();

    Serial.println("\nâœ… NTP åŒæ­¥æˆåŠŸ");

    char timeStr[64];
    lastSyncMillis = millis();  // è¨˜éŒ„å°æ™‚æˆåŠŸæ™‚é–“
  } else {
    Serial.println("\nâŒ NTP åŒæ­¥å¤±æ•—");
    ntpSynced = false;
  }
    delayUntilAlignedRTCWrite();  // å°é½Šæ•´åˆ†é˜
}

void delayUntilAlignedRTCWrite() {
  struct timeval tv;
  gettimeofday(&tv, NULL);

  int64_t micros_now = tv.tv_sec * 1000000LL + tv.tv_usec;
  int64_t micros_next_minute = ((tv.tv_sec / 60) + 1) * 60 * 1000000LL;

  int64_t delay_us = micros_next_minute - micros_now;

  Serial.printf("â± å°é½Šå»¶é² %.3f ç§’...", delay_us / 1000000.0);
  Serial.println("\nâœ… åˆå§‹åŒ–å®Œæˆï¼Œæº–å‚™ç™¼å°„è¨ˆæ™‚æ³¢è¨Šè™Ÿ");
  if (delay_us >= 1000) {
    delay(delay_us / 1000);                  // æ¯«ç§’ä»¥ä¸Šéƒ¨åˆ†
    delayMicroseconds(delay_us % 1000);      // å‰©ä¸‹å¾®ç§’
  } else {
    delayMicroseconds(delay_us);
  }
}

bool hasAligned = false;  // â± åªåœ¨ç¬¬ä¸€æ¬¡å°é½Š

void loop() {
  if (!ntpSynced) {
    delay(1000);
    return;
  }

  // å°é½Šæ¯ç§’èµ·é»ï¼ˆå¾®ç§’ï¼‰
  while (true) {
    uint64_t nowMicros = esp_timer_get_time();
    if ((nowMicros - ntpSyncedMicros) % 1000000UL < 1000) break;
    delayMicroseconds(100);
  }

  // æ¨ç®—ç›®å‰ç§’æ•¸
  uint64_t nowMicros = esp_timer_get_time();
  time_t currentTime = ntpSyncedTime + ((nowMicros - ntpSyncedMicros) / 1000000ULL);

  struct tm timeInfo;
  localtime_r(&currentTime, &timeInfo);

  printAndSendJJY(timeInfo);

  // âœ… è‡ªå‹•é‡æ–°å°æ™‚é‚è¼¯
  if (millis() - lastSyncMillis > syncInterval) {
    Serial.printf("â³ è‡ªå‹•é‡æ–°å°æ™‚è§¸ç™¼ï¼ˆé–“éš” %lu msï¼‰\n", syncInterval);
    resyncNTP();  // å‘¼å«é‡æ–°å°æ™‚å‡½å¼
  }
}


void set_year(int n){
  
  int m = dec2BCD(n);

  sg[48] = m % 2; m = m >> 1;
  sg[47] = m % 2; m = m >> 1;
  sg[46] = m % 2; m = m >> 1;
  sg[45] = m % 2; m = m >> 1;

  sg[44] = m % 2; m = m >> 1;
  sg[43] = m % 2; m = m >> 1;
  sg[42] = m % 2; m = m >> 1;
  sg[41] = m % 2;
}

void printAndSendJJY(struct tm &timeInfo) {
  int se, sh;
  se = timeInfo.tm_sec;
  sh = 0;

  // âœ… è™•ç†é–ç§’è£œæ­£
  if (timeInfo.tm_sec == 60) {
    sg[53] = LS1 = 1;
    sg[54] = LS2 = 0;
    se = 59;
    sh = 1;
  } else if (timeInfo.tm_sec == 61) {
    sg[53] = LS1 = 1;
    sg[54] = LS2 = 1;
    se = 58;
    sh = 2;
  }

  // âœ… è¨­å®šæ™‚é–“ç¢¼
  set_min(timeInfo.tm_min);
  set_hour(timeInfo.tm_hour);
  set_day(timeInfo.tm_yday + 1);
  set_wday(timeInfo.tm_wday);
  set_year(timeInfo.tm_year + 1900 - 2000);

  // âœ… é¡¯ç¤ºç›®å‰æ™‚é–“æˆ³
  char buf[64];
  snprintf(buf, sizeof(buf), "â° %04d/%02d/%02d %02d:%02d:%02d",
           timeInfo.tm_year + 1900, timeInfo.tm_mon + 1, timeInfo.tm_mday,
           timeInfo.tm_hour, timeInfo.tm_min, timeInfo.tm_sec);
  Serial.println(buf);

  // âœ… é¡¯ç¤ºé å‚™ç™¼é€è³‡è¨Š
  Serial.printf("ğŸ“¡ é–‹å§‹ç™¼é€æ™‚é–“ç¢¼ï¼šå¾ %02d ç§’èµ·ï¼Œé è¨ˆé•·åº¦ %d ç§’\n", se, 60 + sh - se);

  // âœ… é¡¯ç¤º sg[] è³‡æ–™å…§å®¹
  char t[64];
  for (int i = se; i < 60 + sh && i < 62; ++i) {
    // âœ… éŒ¯èª¤å€¼ä¿è­·
    if (sg[i] != -1 && sg[i] != 0 && sg[i] != 1 && sg[i] != 255) {
      Serial.printf("âš ï¸ sg[%d] å€¼ç•°å¸¸ï¼š%dï¼Œè‡ªå‹•ä¿®æ­£ç‚º 0\n", i, sg[i]);
      sg[i] = 0;
    }

    // âœ… è¼¸å‡º sg å€¼
    snprintf(t, sizeof(t), "%02d ", sg[i]);
    Serial.print(t);

    if ((i - se + 1) % 10 == 0) {
      Serial.println();  // æ¯ 10 ç­†æ›è¡Œ
    }

    // âœ… å¯¦éš›ç™¼æ³¢
    switch (sg[i]) {
      case -1:
      case 255:
        mark();
        break;
      case 0:
        zero();
        break;
      case 1:
        one();
        break;
      default:
        zero();  // fallback
        break;
    }

    // é–ƒçˆ LED æ¯ç§’æç¤º
    if (millis() - lastBlink >= 1000) {
      ledState = !ledState;
      digitalWrite(STATUS_LED, ledState ? HIGH : LOW);
      lastBlink = millis();
    }
  }
  Serial.println();  // çµå°¾æ›è¡Œ
}


void set_day(int n){
  
  int m = dec2BCD(n);

  sg[33] = m % 2; m = m >> 1;
  sg[32] = m % 2; m = m >> 1;
  sg[31] = m % 2; m = m >> 1;
  sg[30] = m % 2; m = m >> 1;

  sg[28] = m % 2; m = m >> 1;
  sg[27] = m % 2; m = m >> 1;
  sg[26] = m % 2; m = m >> 1;
  sg[25] = m % 2; m = m >> 1;

  sg[23] = m % 2; m = m >> 1;
  sg[22] = m % 2;
}

void set_wday(int m){

  sg[52] = m % 2; m = m >> 1;
  sg[51] = m % 2; m = m >> 1;
  sg[50] = m % 2;
}

void set_hour(int n){
  
  int m = dec2BCD(n);

  sg[18] = m % 2; m = m >> 1;
  sg[17] = m % 2; m = m >> 1;
  sg[16] = m % 2; m = m >> 1;
  sg[15] = m % 2; m = m >> 1;
  
  sg[13] = m % 2; m = m >> 1;
  sg[12] = m % 2;
  
  char PA1 = sg[18] ^ sg[17] ^ sg[16] ^ sg[15] ^ sg[13] ^ sg[12]; //PA1 = (20h+10h+8h+4h+2h+1h) mod 2
  sg[36] = PA1;
}

void set_min(int n){
  
  int m = dec2BCD(n);


  sg[8] = m % 2; m = m >> 1;
  sg[7] = m % 2; m = m >> 1;
  sg[6] = m % 2; m = m >> 1;
  sg[5] = m % 2; m = m >> 1;

  sg[3] = m % 2; m = m >> 1;
  sg[2] = m % 2; m = m >> 1;
  sg[1] = m % 2;

  char PA2 = sg[8] ^ sg[7] ^ sg[6] ^ sg[5] ^ sg[3] ^ sg[2] ^ sg[1]; //PA2 = (40m+20m+10m+8m+4m+2m+1m) mod 2
  sg[37] = PA2;
}


void set_fix(){
  sg[0] = sg[9] = sg[19] = sg[29] = sg[39] = sg[49] = sg[59] = M;
  sg[4] = sg[10] = sg[11] = sg[14] = sg[20] = sg[21] = sg[24] = sg[34] = sg[35] = sg[55] = sg[56] = sg[57] = sg[58] = 0;
  sg[38] = sg[40] = 0;
  sg[53] = sg[54] = 0;
  
}

int dec2BCD(int decimal) {
    int bcd = 0;
    int multiplier = 1;

    while (decimal > 0) {
        int digit = decimal % 10;
        bcd += digit * multiplier;
        multiplier *= 16; 
        decimal /= 10;
    }

    return bcd;
    
    ///printf("BCD: %X\n", bcd);
}


void mark() {   // 0.2sec
  ledcWrite(ledChannel, 127);
  delay(200);
  ledcWrite(ledChannel, 0);
  delay(800);
}

void zero() {  // 0.8sec
  ledcWrite(ledChannel, 127);
  delay(800);
  ledcWrite(ledChannel, 0);
  delay(200);
}

void one() {    // 0.5sec
  ledcWrite(ledChannel, 127);
  delay(500);
  ledcWrite(ledChannel, 0);
  delay(500);
}

void resyncNTP() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("âš ï¸ ç„¡æ³•é‡æ–°å°æ™‚ï¼šWiFi å°šæœªé€£ç·š");
    ntpSyncedMicros = 0;
    ntpSynced = false;
    return;
  }

  Serial.println("ğŸ”„ å˜—è©¦é€é NTP é‡æ–°å°æ™‚...");
  configTime(timezoneOffsetSec, 0, "time.stdtime.gov.tw", "time.google.com", "ntp.twnic.tw");

  struct tm timeInfo;
  if (getLocalTime(&timeInfo)) {
    ntpSynced = true;
    time(&ntpSyncedTime);
    ntpSyncedMicros = esp_timer_get_time();
    lastSyncMillis = millis();  // æ›´æ–°å°æ™‚åŸºæº–æ™‚é–“

    Serial.printf("âœ… é‡æ–°æ ¡æ™‚æˆåŠŸï¼š%04d/%02d/%02d %02d:%02d:%02d\n",
                  timeInfo.tm_year + 1900,
                  timeInfo.tm_mon + 1,
                  timeInfo.tm_mday,
                  timeInfo.tm_hour,
                  timeInfo.tm_min,
                  timeInfo.tm_sec);
  } else {
    Serial.println("âŒ é‡æ–°æ ¡æ™‚å¤±æ•—ï¼Œç¶­æŒç¾æœ‰æ¨¡å¼");
    ntpSynced = false;
    ntpSyncedMicros = 0;
  }
}
